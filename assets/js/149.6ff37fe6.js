(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{437:function(v,t,_){"use strict";_.r(t);var l=_(1),i=Object(l.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"v8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8"}},[v._v("#")]),v._v(" v8")]),v._v(" "),t("p",[v._v("js 在执行的时候都要经过 V8")]),v._v(" "),t("h2",{attrs:{id:"libuv"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#libuv"}},[v._v("#")]),v._v(" libuv")]),v._v(" "),t("p",[v._v("不属于 v8，但是在 node 执行过程中辅助的一个环节")]),v._v(" "),t("p",[v._v("执行逻辑与顺序")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("内部深层原理")])]),v._v(" "),t("li",[t("p",[v._v("c 的实现机制")])]),v._v(" "),t("li",[t("p",[v._v("DSL\\NLP\\AST")])]),v._v(" "),t("li",[t("p",[v._v("浏览器运行机制\n详细过程")])]),v._v(" "),t("li",[t("p",[v._v("node 启动时，创建了一个类似 while(true)的循环体（每次执行一次循环体就称为一次 tick）")])]),v._v(" "),t("li",[t("p",[v._v("每个 tick 的过程就是查看是否有事件等待处理")])]),v._v(" "),t("li",[t("p",[v._v("如果有则取出事件及其相关的回调函数去执行，然后执行下一个 tick\n执行逻辑")])])]),v._v(" "),t("p",[v._v("先询问事件观察者是否有任务需要执行\n总结：")]),v._v(" "),t("ul",[t("li",[v._v("在执行的时候是一个 while(true) 的循环体，")]),v._v(" "),t("li",[v._v("整个过程不需要等待回调函数执行完成，他会继续向下执行，直到观察者回答没有了，线程才结束")])]),v._v(" "),t("h2",{attrs:{id:"浏览器中的-event-loop-跟-libuv-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中的-event-loop-跟-libuv-的区别"}},[v._v("#")]),v._v(" 浏览器中的 event loop 跟 libuv 的区别")]),v._v(" "),t("p",[v._v("它主要有一个主线程和 stack 调用栈，所有任务都会等主线程去执行")])])}),[],!1,null,null,null);t.default=i.exports}}]);