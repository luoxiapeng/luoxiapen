(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{433:function(v,t,e){"use strict";e.r(t);var r=e(1),_=Object(r.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"闭包给-chrome-v8-带来的问题及其解决策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包给-chrome-v8-带来的问题及其解决策略"}},[v._v("#")]),v._v(" 闭包给 Chrome V8 带来的问题及其解决策略")]),v._v(" "),t("p",[v._v("惰性解析")]),v._v(" "),t("p",[v._v("所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("在编译 JavaScript 代码的过程中，V8 并不会一次性将所有的 JavaScript 解析为中间代码，这主要是基于以下两点：")]),v._v(" "),t("ul",[t("li",[v._v("首先，如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度，让用户感觉到卡顿。因为有时候一个页面的 JavaScript 代码很大，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；")]),v._v(" "),t("li",[v._v("其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存。")])])]),v._v(" "),t("li",[t("p",[v._v("基于以上的原因，所有主流的 JavaScript 虚拟机都实现了惰性解析。")])]),v._v(" "),t("li",[t("p",[v._v("闭包给惰性解析带来的问题：上文的 d 不能随着 foo 函数的执行上下文被销毁掉。")])])]),v._v(" "),t("p",[v._v("预解析器")]),v._v(" "),t("p",[v._v("V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析")]),v._v(" "),t("ul",[t("li",[v._v("判断当前函数是不是存在一些语法上的错误，发现了语法错误，那么就会向 V8 抛出语法错误；")]),v._v(" "),t("li",[v._v("检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题")])]),v._v(" "),t("p",[v._v("V8 内部是如何存储对象的：快属性和慢属性\n因为 JavaScript 中的对象是由一组组属性和值组成的，所以最简单的方式是使用一个字典来保存属性和值，但是由于字典是非线性结构，所以如果使用字典，读取效率会大大降低。为了提升查找效率，V8 在对象中添加了两个隐藏属性，排序属性和常规属性 element 属性指向了 elements 对象，在 elements 对象中，会按照顺序存放排序属性。properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存常规属性。")]),v._v(" "),t("p",[v._v("通过引入这两个属性，加速了 V8 查找属性的速度，为了更加进一步提升查找效率，V8 还实现了内置内属性的策略，当常规属性少于一定数量时，V8 就会将这些常规属性直接写进对象中，这样又节省了一个中间步骤。")]),v._v(" "),t("p",[v._v("但是如果对象中的属性过多时，或者存在反复添加或者删除属性的操作，那么 V8 就会将线性的存储模式降级为非线性的字典存储模式，这样虽然降低了查找速度，但是却提升了修改对象的属性的速度。")])])}),[],!1,null,null,null);t.default=_.exports}}]);