(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{554:function(a,t,s){"use strict";s.r(t);var n=s(1),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"javascript-查漏补缺四"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-查漏补缺四"}},[a._v("#")]),a._v(" javascript 查漏补缺四")]),a._v(" "),s("h2",{attrs:{id:"call-和-apply-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#call-和-apply-的区别"}},[a._v("#")]),a._v(" .call() 和 .apply() 的区别？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("它们的作用一模一样，区别仅在于传入参数的形式的不同。\n\napply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。\n\ncall 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。\n\n")])])]),s("h2",{attrs:{id:"javascript-类数组对象的定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-类数组对象的定义"}},[a._v("#")]),a._v(" JavaScript 类数组对象的定义？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。\n\n常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length\n属性值，代表可接收的参数个数。\n\n")])])]),s("p",[a._v("常见的类数组转换为数组的方法有这样几种：")]),a._v(" "),s("p",[a._v("（1）通过 call 调用数组的 slice 方法来实现转换")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("slice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("arrayLike"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("（2）通过 call 调用数组的 splice 方法来实现转换")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("splice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("call")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("arrayLike"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("（3）通过 apply 调用数组的 concat 方法来实现转换")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Array")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("concat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("apply")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" arrayLike"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("（4）通过 Array.from 方法来实现转换")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[a._v("Array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("from")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("arrayLike"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("h2",{attrs:{id:"数组和对象有哪些原生方法-列举一下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组和对象有哪些原生方法-列举一下"}},[a._v("#")]),a._v(" 数组和对象有哪些原生方法，列举一下？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\n\n数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\n\n数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\n\n数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\n\n数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\n\n数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\n\n数组归并方法 reduce() 和 reduceRight() 方法\n\n")])])]),s("h2",{attrs:{id:"数组的-fill-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组的-fill-方法"}},[a._v("#")]),a._v(" 数组的 fill 方法？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。\nfill 方法接受三个参数 value，start 以及 end，start 和 end 参数是可选的，其默认值分别为 0 和 this 对象的 length 属性值。\n\n")])])]),s("h2",{attrs:{id:"的长度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#的长度"}},[a._v("#")]),a._v(" [,,,] 的长度？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果你想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。\n\nJavaScript 一开始就支持数组字面值中的尾后逗号，随后向对象字面值（ECMAScript 5）中添加了尾后逗号。最近（ECMAS\ncript 2017），又将其添加到函数参数中。但是 JSON 不支持尾后逗号。\n\n如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙）。稀疏数组的长度为逗号的数\n量。\n\n")])])]),s("h2",{attrs:{id:"javascript-中的作用域与变量声明提升"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-中的作用域与变量声明提升"}},[a._v("#")]),a._v(" JavaScript 中的作用域与变量声明提升？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("变量提升的表现是，无论我们在函数中何处位置声明的变量，好像都被提升到了函数的首部，我们可以在变量声明前访问到而不会报错。\n\n造成变量声明提升的本质原因是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，我们会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。\n\n")])])]),s("h2",{attrs:{id:"如何编写高性能的-javascript"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何编写高性能的-javascript"}},[a._v("#")]),a._v(" 如何编写高性能的 Javascript ？")]),a._v(" "),s("ul",[s("li",[a._v("1.使用位运算代替一些简单的四则运算。")]),a._v(" "),s("li",[a._v("2.避免使用过深的嵌套循环。")]),a._v(" "),s("li",[a._v("3.不要使用未定义的变量。")]),a._v(" "),s("li",[a._v("4.当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。")])]),a._v(" "),s("h2",{attrs:{id:"简单介绍一下-v8-引擎的垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简单介绍一下-v8-引擎的垃圾回收机制"}},[a._v("#")]),a._v(" 简单介绍一下 V8 引擎的垃圾回收机制")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。\n\n新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。\n\n新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：\n\n（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。\n\n（2）如果对象不存活，则释放对象的空间。\n\n（3）最后将 From 空间和 To 空间角色进行交换。\n\n新生代对象晋升到老生代有两个条件：\n\n（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。\n\n（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。\n\n老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。\n\n由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。\n\n")])])]),s("h2",{attrs:{id:"哪些操作会造成内存泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哪些操作会造成内存泄漏"}},[a._v("#")]),a._v(" 哪些操作会造成内存泄漏？")]),a._v(" "),s("p",[a._v("相关知识点：")]),a._v(" "),s("ul",[s("li",[a._v("1.意外的全局变量")]),a._v(" "),s("li",[a._v("2.被遗忘的计时器或回调函数")]),a._v(" "),s("li",[a._v("3.脱离 DOM 的引用")]),a._v(" "),s("li",[a._v("4.闭包")])]),a._v(" "),s("p",[a._v("回答：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。\n\n第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留\n在内存中，而无法被回收。\n\n第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回\n收。\n\n第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。\n\n")])])]),s("h2",{attrs:{id:"需求-实现一个页面操作不会整页刷新的网站-并且能在浏览器前进、后退时正确响应。给出你的技术实现方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#需求-实现一个页面操作不会整页刷新的网站-并且能在浏览器前进、后退时正确响应。给出你的技术实现方案"}},[a._v("#")]),a._v(" 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history\n对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可\n以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。\n\n使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问\n题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。\n\n")])])]),s("h2",{attrs:{id:"如何判断当前脚本运行在浏览器还是-node-环境中-阿里"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何判断当前脚本运行在浏览器还是-node-环境中-阿里"}},[a._v("#")]),a._v(" 如何判断当前脚本运行在浏览器还是 node 环境中？（阿里）")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("this === window ? 'browser' : 'node';\n\n通过判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中。\n")])])]),s("h2",{attrs:{id:"把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别-浏览器会如何解析它们"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#把-script-标签放在页面的最底部的-body-封闭之前和封闭之后有什么区别-浏览器会如何解析它们"}},[a._v("#")]),a._v(" 把 script 标签放在页面的最底部的 body 封闭之前和封闭之后有什么区别？浏览器会如何解析它们？")]),a._v(" "),s("p",[a._v("详细资料可以参考： 《为什么把 script 标签放在 body 结束标签之后 html 结束标签之前？》 《从 Chrome 源码看浏览器如何加载资源》")]),a._v(" "),s("h2",{attrs:{id:"移动端的点击事件的有延迟-时间是多久-为什么会有-怎么解决这个延时"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#移动端的点击事件的有延迟-时间是多久-为什么会有-怎么解决这个延时"}},[a._v("#")]),a._v(" 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("移动端点击有 300ms 的延迟是因为移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。\n\n")])])]),s("p",[a._v("有三种办法来解决这个问题：")]),a._v(" "),s("ul",[s("li",[a._v("1.通过 meta 标签禁用网页的缩放。")]),a._v(" "),s("li",[a._v("2.通过 meta 标签将网页的 viewport 设置为 ideal viewport。")]),a._v(" "),s("li",[a._v("3.调用一些 js 库，比如 FastClick")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。\n\n")])])]),s("h2",{attrs:{id:"什么是-前端路由-什么时候适合使用-前端路由-前端路由-有哪些优点和缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-前端路由-什么时候适合使用-前端路由-前端路由-有哪些优点和缺点"}},[a._v("#")]),a._v(" 什么是“前端路由”？什么时候适合使用“前端路由”？“前端路由”有哪些优点和缺点？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("（1）什么是前端路由？\n\n前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的。\n\n（2）什么时候使用前端路由？\n\n在单页面应用，大部分页面结构不变，只改变部分内容的使用\n\n（3）前端路由有什么优点和缺点？\n\n优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户\n\n缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置\n\n前端路由一共有两种实现方式，一种是通过 hash 的方式，一种是通过使用 pushState 的方式。\n\n")])])]),s("h2",{attrs:{id:"如何测试前端代码么-知道-bdd-tdd-unit-test-么-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qunit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何测试前端代码么-知道-bdd-tdd-unit-test-么-知道怎么测试你的前端工程么-mocha-sinon-jasmin-qunit"}},[a._v("#")]),a._v(" 如何测试前端代码么？ 知道 BDD, TDD, Unit Test 么？ 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)？")]),a._v(" "),s("p",[a._v("详细资料可以参考： 《浅谈前端单元测试》")]),a._v(" "),s("h2",{attrs:{id:"检测浏览器版本版本有哪些方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#检测浏览器版本版本有哪些方式"}},[a._v("#")]),a._v(" 检测浏览器版本版本有哪些方式？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("检测浏览器版本一共有两种方式：\n\n一种是检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。\n\n第二种方式是功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。\n\n")])])]),s("h2",{attrs:{id:"什么是-polyfill"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-polyfill"}},[a._v("#")]),a._v(" 什么是 Polyfill ？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。\n\n比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。\n\n一个 shim 是一个库，有自己的 API，而不是单纯实现原生不支持的 API。\n\n")])])]),s("h2",{attrs:{id:"使用-js-实现获取文件扩展名"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用-js-实现获取文件扩展名"}},[a._v("#")]),a._v(" 使用 JS 实现获取文件扩展名？")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// String.lastIndexOf() 方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 对于 'filename' 和 '.hiddenfile' ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(>>>) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v('// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为""。')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getFileExtension")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("filename")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" filename"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("slice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("filename"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("lastIndexOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'.'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("h2",{attrs:{id:"介绍一下-js-的节流与防抖"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下-js-的节流与防抖"}},[a._v("#")]),a._v(" 介绍一下 js 的节流与防抖？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 函数防抖： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。\n\n// 函数节流： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。\n\n// 函数防抖的实现\nfunction debounce(fn, wait) {\n  var timer = null;\n\n  return function() {\n    var context = this,\n      args = arguments;\n\n    // 如果此时存在定时器的话，则取消之前的定时器重新记时\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n\n    // 设置定时器，使事件间隔指定事件后执行\n    timer = setTimeout(() => {\n      fn.apply(context, args);\n    }, wait);\n  };\n}\n\n// 函数节流的实现;\nfunction throttle(fn, delay) {\n  var preTime = Date.now();\n\n  return function() {\n    var context = this,\n      args = arguments,\n      nowTime = Date.now();\n\n    // 如果两次时间间隔超过了指定时间，则执行函数。\n    if (nowTime - preTime >= delay) {\n      preTime = Date.now();\n      return fn.apply(context, args);\n    }\n  };\n}\n\n")])])]),s("p",[a._v("回答：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\n\n函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。\n\n")])])]),s("h2",{attrs:{id:"object-is-与原来的比较操作符-、-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-is-与原来的比较操作符-、-的区别"}},[a._v("#")]),a._v(" Object.is() 与原来的比较操作符 “===”、“==” 的区别？")]),a._v(" "),s("p",[a._v("相关知识点：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("两等号判等，会在比较时进行类型转换。\n三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）。\n\nObject.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true.\n\nObject.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。\n\n")])])]),s("p",[a._v("回答：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("使用双等号进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。\n\n使用三等号进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。\n\n使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。\n\n")])])]),s("h2",{attrs:{id:"escape-encodeuri-encodeuricomponent-有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#escape-encodeuri-encodeuricomponent-有什么区别"}},[a._v("#")]),a._v(" escape,encodeURI,encodeURIComponent 有什么区别？")]),a._v(" "),s("p",[a._v("相关知识点：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("escape 和 encodeURI 都属于 Percent-encoding，基本功能都是把 URI 非法字符转化成合法字符，转化后形式类似「%*」。\n它们的根本区别在于，escape 在处理 0xff 之外字符的时候，是直接使用字符的 unicode 在前面加上一个「%u」，而 encode URI 则是先进行 UTF-8，再在 UTF-8 的每个字节码前加上一个「%」；在处理 0xff 以内字符时，编码方式是一样的（都是「%XX」，XX 为字符的 16 进制 unicode，同时也是字符的 UTF-8），只是范围（即哪些字符编码哪些字符不编码）不一样。\n\n")])])]),s("p",[a._v("回答：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。\n\nencodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。\n\nescape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。\n\n")])])]),s("h2",{attrs:{id:"unicode-和-utf-8-之间的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unicode-和-utf-8-之间的关系"}},[a._v("#")]),a._v(" Unicode 和 UTF-8 之间的关系？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。\n\nUTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。\n\n")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);