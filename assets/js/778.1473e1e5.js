(window.webpackJsonp=window.webpackJsonp||[]).push([[778],{1065:function(o,t,s){"use strict";s.r(t);var i=s(1),n=Object(i.a)({},(function(){var o=this,t=o._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[t("h1",{attrs:{id:"模块二导读-逻辑复用最佳实践-composition-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块二导读-逻辑复用最佳实践-composition-api"}},[o._v("#")]),o._v(" 模块二导读 | 逻辑复用最佳实践：Composition API")]),o._v(" "),t("p",[o._v("在课前导读《一文看懂 Vue.js 3.0 的优化》中，我们讲到 Vue.js 3.0 设计了一个很强大的 API —— Composition API，它主要用来优化代码逻辑的组织和复用。")]),o._v(" "),t("p",[o._v("从语法上看，它提供了一个 setup 启动函数作为逻辑组织的入口，暴露了响应式 API 为用户所用，也提供了生命周期函数以及依赖注入的接口，这让我们不依托于 Options API 也可以完成一个组件的开发，并且更有利于代码逻辑的组织和复用。")]),o._v(" "),t("p",[o._v("但是我们要明确一点，Composition API 属于 API 的增强，它并不是 Vue.js 3.0 组件开发的范式，如果你的组件足够简单，你还是可以使用 Options API。")]),o._v(" "),t("p",[o._v("了解了 Composition API 的应用场景和使用方式后，我们需要进一步思考，这样一套 API 是如何设计出来的？它是怎么和组件配合的？在组件整个渲染过程中它又做了哪些事情？带着这些疑问，我们一起来学习这一模块的内容，探索 Composition API 的实现原理。")])])}),[],!1,null,null,null);t.default=n.exports}}]);