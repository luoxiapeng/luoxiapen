(window.webpackJsonp=window.webpackJsonp||[]).push([[195],{482:function(a,n,t){"use strict";t.r(n);var e=t(1),s=Object(e.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"javascript-查漏补缺一"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-查漏补缺一"}},[a._v("#")]),a._v(" javascript 查漏补缺一")]),a._v(" "),n("h2",{attrs:{id:"javascript-面试题-助你查漏补缺"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-面试题-助你查漏补缺"}},[a._v("#")]),a._v(" JavaScript 面试题，助你查漏补缺")]),a._v(" "),n("p",[a._v("最近在整理 JavaScript 的时候发现遇到了很多面试中常见的面试题，本部分主要是作者在 Github 等各大论坛收录的 JavaScript 相关知识和一些相关面试题时所做的笔记，分享这份总结给大家，对大家对 JavaScript 的可以来一次全方位的检漏和排查，感谢 CavsZhouyou 的付出，原文链接放在文章最下方，如果出现错误，希望大家共同指出！")]),a._v(" "),n("h2",{attrs:{id:"介绍-js-的基本数据类型。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#介绍-js-的基本数据类型。"}},[a._v("#")]),a._v(" 介绍 js 的基本数据类型。")]),a._v(" "),n("p",[a._v("js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 类型，\n代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。")]),a._v(" "),n("h1",{attrs:{id:"javascript-有几种类型的值-你能画一下他们的内存图吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-有几种类型的值-你能画一下他们的内存图吗"}},[a._v("#")]),a._v(" JavaScript 有几种类型的值？你能画一下他们的内存图吗？")]),a._v(" "),n("p",[a._v("涉及知识点：")]),a._v(" "),n("ul",[n("li",[a._v("栈：原始数据类型（Undefined、Null、Boolean、Number、String）")]),a._v(" "),n("li",[a._v("堆：引用数据类型（对象、数组和函数）")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("两种类型的区别是：存储位置不同。\n原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。\n\n引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在\n栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实\n体。\n")])])]),n("p",[a._v("回答：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。\n\n基本数据类型....（参考1）\n\n复杂数据类型指的是 Object 类型，所有其他的如 Array、Date 等数据类型都可以理解为 Object 类型的子类。\n\n两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中\n保存对应的指针来获取堆中的值。\n")])])]),n("h2",{attrs:{id:"什么是堆-什么是栈-它们之间有什么区别和联系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是堆-什么是栈-它们之间有什么区别和联系"}},[a._v("#")]),a._v(" 什么是堆？什么是栈？它们之间有什么区别和联系？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("堆和栈的概念存在于数据结构中和操作系统内存中。\n\n在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全\n二叉树是堆的一种实现方式。\n\n在操作系统中，内存被分为栈区和堆区。\n\n栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n\n堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。\n")])])]),n("h2",{attrs:{id:"内部属性-class-是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内部属性-class-是什么"}},[a._v("#")]),a._v(" 内部属性 [[Class]] 是什么？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('// 所有 typeof 返回值为 "object" 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非\n// 传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 Object.prototype.toString(..) 来查看。例如：\n\nObject.prototype.toString.call( [1,2,3] );\n// "[object Array]"\n\nObject.prototype.toString.call( /regex-literal/i );\n// "[object RegExp]"\n\n')])])]),n("h2",{attrs:{id:"介绍-js-有哪些内置对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#介绍-js-有哪些内置对象"}},[a._v("#")]),a._v(" 介绍 js 有哪些内置对象？")]),a._v(" "),n("p",[a._v("涉及知识点：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('全局的对象（ global objects ）或称标准内置对象，不要和 "全局对象（global object）" 混淆。这里说的全局的对象是说在\n全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。\n\n标准内置对象的分类\n\n（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。\n\n例如 Infinity、NaN、undefined、null 字面量\n\n（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。\n\n例如 eval()、parseFloat()、parseInt() 等\n\n（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。\n\n例如 Object、Function、Boolean、Symbol、Error 等\n\n（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。\n\n例如 Number、Math、Date\n\n（5）字符串，用来表示和操作字符串的对象。\n\n例如 String、RegExp\n\n（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array\n\n（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。\n\n例如 Map、Set、WeakMap、WeakSet\n\n（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。\n\n例如 SIMD 等\n\n（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。\n\n例如 JSON 等\n\n（10）控制抽象对象\n\n例如 Promise、Generator 等\n\n（11）反射\n\n例如 Reflect、Proxy\n\n（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。\n\n例如 Intl、Intl.Collator 等\n\n（13）WebAssembly\n\n（14）其他\n\n')])])]),n("p",[a._v("回答：")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函\n数对象。一般我们经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构\n造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。\n")])])]),n("h2",{attrs:{id:"undefined-与-undeclared-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#undefined-与-undeclared-的区别"}},[a._v("#")]),a._v(" undefined 与 undeclared 的区别？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。\n\n对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typ\neof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 "undefined"。\n')])])]),n("h2",{attrs:{id:"null-和-undefined-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined-的区别"}},[a._v("#")]),a._v(" null 和 undefined 的区别？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。\n\nundefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null\n主要用于赋值给一些可能会返回对象的变量，作为初始化。\n\nundefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它\n会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。\n\n当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等\n号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。\n")])])]),n("h2",{attrs:{id:"如何获取安全的-undefined-值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何获取安全的-undefined-值"}},[a._v("#")]),a._v(" 如何获取安全的 undefined 值？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。\n\n表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。\n\n按惯例我们用 void 0 来获得 undefined。\n\n")])])]),n("h2",{attrs:{id:"说几条写-javascript-的基本规范"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#说几条写-javascript-的基本规范"}},[a._v("#")]),a._v(" 说几条写 JavaScript 的基本规范？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("在平常项目开发中，我们遵守一些这样的基本规范，比如说：\n\n（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，不允许出现两个连续的 var 声明，声明时\n    如果变量没有值，应该给该变量赋值对应类型的初始值，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。\n\n（2）代码中出现地址、时间等字符串时需要使用常量代替。\n\n（3）在进行比较的时候吧，尽量使用'===', '!=='代替'==', '!='。\n\n（4）不要在内置对象的原型上添加方法，如 Array, Date。\n\n（5）switch 语句必须带有 default 分支。\n\n（6）for 循环必须使用大括号。\n\n（7）if 语句必须使用大括号。\n\n")])])]),n("h2",{attrs:{id:"javascript-原型-原型链-有什么特点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-原型-原型链-有什么特点"}},[a._v("#")]),a._v(" JavaScript 原型，原型链？ 有什么特点？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对\n象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部\n将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们\n是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这\n个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对\n象的原型。\n\n当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又\n会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就\n是我们新建的对象为什么能够使用 toString() 等方法的原因。\n\n特点：\n\nJavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与\n之相关的对象也会继承这一改变。\n\n")])])]),n("h2",{attrs:{id:"js-获取原型的方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-获取原型的方法"}},[a._v("#")]),a._v(" js 获取原型的方法？")]),a._v(" "),n("ul",[n("li",[a._v("p.proto")]),a._v(" "),n("li",[a._v("p.constructor.prototype")]),a._v(" "),n("li",[a._v("Object.getPrototypeOf(p)")])]),a._v(" "),n("h2",{attrs:{id:"在-js-中不同进制数字的表示方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在-js-中不同进制数字的表示方式"}},[a._v("#")]),a._v(" 在 js 中不同进制数字的表示方式")]),a._v(" "),n("ul",[n("li",[a._v("以 0X、0x 开头的表示为十六进制。")]),a._v(" "),n("li",[a._v("以 0、0O、0o 开头的表示为八进制。")]),a._v(" "),n("li",[a._v("以 0B、0b 开头的表示为二进制格式。")])]),a._v(" "),n("h2",{attrs:{id:"js-中整数的安全范围是多少"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-中整数的安全范围是多少"}},[a._v("#")]),a._v(" js 中整数的安全范围是多少？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1，\n即9007199254740991，在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数是-9007199254740991，在 ES6 中\n被定义为 Number.MIN_SAFE_INTEGER。\n\n如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次\n计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数\n来判断。\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);