(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{432:function(v,_,a){"use strict";a.r(_);var l=a(1),i=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"隐藏类和内联缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隐藏类和内联缓存"}},[v._v("#")]),v._v(" 隐藏类和内联缓存")]),v._v(" "),_("p",[v._v("JavaScript 是一门动态语言，其执行效率要低于静态语言，V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存。")]),v._v(" "),_("h2",{attrs:{id:"为什么静态语言的效率更高"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么静态语言的效率更高"}},[v._v("#")]),v._v(" 为什么静态语言的效率更高?")]),v._v(" "),_("p",[v._v("静态语言中，如 C++ 在声明一个对象之前需要定义该对象的结构，代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中是无法被改变的。可以直接通过偏移量查询来查询对象的属性值，这也就是静态语言的执行效率高的一个原因。")]),v._v(" "),_("p",[v._v("JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 obj.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也就是说 V8 并不知道该对象的具体的形状。那么，当在 JavaScript 中要查询对象 obj 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。")]),v._v(" "),_("p",[v._v("##将静态的特性引入到 V8\nV8 采用的一个思路就是将 JavaScript 中的对象静态化，也就是 V8 在运行 JavaScript 的过程中，会假设 JavaScript 中的对象是静态的。")]),v._v(" "),_("p",[v._v("具体地讲，V8 对每个对象做如下两点假设：")]),v._v(" "),_("ul",[_("li",[v._v("对象创建好了之后就不会添加新的属性；")]),v._v(" "),_("li",[v._v("对象创建好了之后也不会删除属性。\n符合这两个假设之后，V8 就可以对 JavaScript 中的对象做深度优化了。V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：")])]),v._v(" "),_("p",[v._v("对象中所包含的所有的属性；\n每个属性相对于对象的偏移量。\n有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。")]),v._v(" "),_("p",[v._v("在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类")]),v._v(" "),_("p",[v._v("map 描述了对象的内存布局，比如对象都包括了哪些属性，这些数据对应于对象的偏移量是多少。")]),v._v(" "),_("p",[v._v("##多个对象共用一个隐藏类\n在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：")]),v._v(" "),_("ul",[_("li",[v._v("减少隐藏类的创建次数，也间接加速了代码的执行速度；")]),v._v(" "),_("li",[v._v("减少了隐藏类的存储空间。 那么，什么情况下两个对象的形状是相同的，要满足以下两点：")]),v._v(" "),_("li",[v._v("相同的属性名称；")]),v._v(" "),_("li",[v._v("相等的属性个数。\n##重新构建隐藏类")]),v._v(" "),_("li",[v._v("给一个对象添加新的属性，删除新的属性，或者改变某个属性的数据类型都会改变这个对象的形状，那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类。")]),v._v(" "),_("li",[v._v("每次给对象添加了一个新属性之后，该对象的隐藏类的地址都会改变，这也就意味着隐藏类也随着改变了；如果删除对象的某个属性，那么对象的形状也就随着发生了改变，这时 V8 也会重建该对象的隐藏类；\n最佳实践")]),v._v(" "),_("li",[v._v("使用字面量初始化对象时，要保证属性的顺序是一致的；")]),v._v(" "),_("li",[v._v("尽量使用字面量一次性初始化完整对象属性；")]),v._v(" "),_("li",[v._v("尽量避免使用 delete 方法。\n##通过内联缓存来提升函数执行效率\n虽然隐藏类能够加速查找对象的速度，但是在 V8 查找对象属性值的过程中，依然有查找对象的隐藏类和根据隐藏类来查找对象属性值的过程。如果一个函数中利用了对象的属性，并且这个函数会被多次执行：")])]),v._v(" "),_("p",[v._v("##通常 V8 获取 obj.x 的流程")]),v._v(" "),_("ul",[_("li",[v._v("找对象 obj 的隐藏类；")]),v._v(" "),_("li",[v._v("再通过隐藏类查找 x 属性偏移量；")]),v._v(" "),_("li",[v._v("然后根据偏移量获取属性值，在这段代码中 loadX 函数会被反复执行，那么获取 obj.x 的流程也需要反复被执行；\n##内联缓存及其原理")]),v._v(" "),_("li",[v._v("函数 loadX 在一个 for 循环里面被重复执行了很多次，因此 V8 会想尽一切办法来压缩这个查找过程，以提升对象的查找效率。这个加速函数执行的策略就是内联缓存 (Inline Cache)，简称为 IC；")]),v._v(" "),_("li",[v._v("IC 的原理：在 V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。")]),v._v(" "),_("li",[v._v("IC 会为每个函数维护一个反馈向量 (FeedBack Vector)，反馈向量记录了函数在执行过程中的一些关键的中间数据。")]),v._v(" "),_("li",[v._v("反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。")]),v._v(" "),_("li",[v._v("当 V8 再次调用 loadX 函数时，比如执行到 loadX 函数中的 return obj.x 语句时，它就会在对应的插槽中查找 x 属性的偏移量，之后 V8 就能直接去内存中获取 obj.x 的属性值了。这样就大大提升了 V8 的执行效率。\n##单态、多态和超态")]),v._v(" "),_("li",[v._v("如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态 (monomorphic)；")]),v._v(" "),_("li",[v._v("如果一个插槽中包含了 2 ～ 4 个隐藏类，那我们称这种状态为多态 (polymorphic)；")]),v._v(" "),_("li",[v._v("如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态 (magamorphic)。")]),v._v(" "),_("li",[v._v("单态的性能优于多态和超态，所以我们需要稍微避免多态和超态的情况。要避免多态和超态，那么就尽量默认所有的对象属性是不变的，比如你写了一个 loadX(obj) 的函数，那么当传递参数时，尽量不要使用多个不同形状的 obj 对象。\n##总结\nV8 引入了内联缓存（IC），IC 会监听每个函数的执行过程，并在一些关键的地方埋下监听点，这些包括了加载对象属性 (Load)、给对象属性赋值 (Store)、还有函数调用 (Call)，V8 会将监听到的数据写入一个称为反馈向量 (FeedBack Vector) 的结构中，同时 V8 会为每个执行的函数维护一个反馈向量。有了反馈向量缓存的临时数据，V8 就可以缩短对象属性的查找路径，从而提升执行效率。但是针对函数中的同一段代码，如果对象的隐藏类是不同的，那么反馈向量也会记录这些不同的隐藏类，这就出现了多态和超态的情况。我们在实际项目中，要尽量避免出现多态或者超态的情况。")])])])}),[],!1,null,null,null);_.default=i.exports}}]);