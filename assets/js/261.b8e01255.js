(window.webpackJsonp=window.webpackJsonp||[]).push([[261],{628:function(e,t,c){"use strict";c.r(t);var s=c(1),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,c=e._self._c||t;return c("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[c("h1",{attrs:{id:"sec-websocket-key-accept-的作用"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#sec-websocket-key-accept-的作用"}},[e._v("#")]),e._v(" Sec-WebSocket-Key/Accept 的作用")]),e._v(" "),c("p",[e._v("前面提到了，Sec-WebSocket-Key/Sec-WebSocket-Accept 在主要作用在于提供基础的防护，减少恶意连接、意外连接。")]),e._v(" "),c("p",[e._v("作用大致归纳如下：")]),e._v(" "),c("ul",[c("li",[c("p",[e._v("避免服务端收到非法的 websocket 连接（比如 http 客户端不小心请求连接 websocket 服务，此时服务端可以直接拒绝连接）")])]),e._v(" "),c("li",[c("p",[e._v("确保服务端理解 websocket 连接。因为 ws 握手阶段采用的是 http 协议，因此可能 ws 连接是被一个 http 服务器处理并返回的，此时客户端可以通过 Sec-WebSocket-Key 来确保服务端认识 ws 协议。（并非百分百保险，比如总是存在那么些无聊的 http 服务器，光处理 Sec-WebSocket-Key，但并没有实现 ws 协议。。。）")])]),e._v(" "),c("li",[c("p",[e._v("用浏览器里发起 ajax 请求，设置 header 时，Sec-WebSocket-Key 以及其他相关的 header 是被禁止的。这样可以避免客户端发送 ajax 请求时，意外请求协议升级（websocket upgrade）")])]),e._v(" "),c("li",[c("p",[e._v("可以防止反向代理（不理解 ws 协议）返回错误的数据。比如反向代理前后收到两次 ws 连接的升级请求，反向代理把第一次请求的返回给 cache 住，然后第二次请求到来时直接把 cache 住的请求给返回（无意义的返回）。")])]),e._v(" "),c("li",[c("p",[e._v("Sec-WebSocket-Key 主要目的并不是确保数据的安全性，因为 Sec-WebSocket-Key、Sec-WebSocket-Accept 的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。")])])]),e._v(" "),c("blockquote",[c("p",[e._v("强调：Sec-WebSocket-Key/Sec-WebSocket-Accept 的换算，只能带来基本的保障，但连接是否安全、数据是否安全、客户端/服务端是否合法的 ws 客户端、ws 服务端，其实并没有实际性的保证。")])])])}),[],!1,null,null,null);t.default=o.exports}}]);