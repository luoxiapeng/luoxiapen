# 变量的解构赋值

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。解构赋值在实际开发中可以大量减少我们的代码量，并且让我们的程序结构更清晰。也许你还是不太明白，那先来一个最简单的数组解构赋值来进行赋值。

> 数组的解构赋值

以前，为变量赋值，我们只能直接指定值。比如下面的代码：

```js
let a = 0
let b = 1
let c = 2
```

而现在我们可以用数组解构的方式来进行赋值。

```js
let [(a, b, c)] = [1, 2, 3]
```

上面的代码表示，可以从数组中提取值，按照位置的对象关系对变量赋值。

## 数组模式和赋值模式统一

可以简单的理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。

```js
let [a, [b, c], d] = [1, [2, 3], 4]
```

如果等号两边形式不一样，很可能获得 undefined 或者直接报错。

## 解构的默认值

解构赋值是允许你使用默认值的，先看一个最简单的默认是的例子。

```js
let [foo = true] = []
console.log(foo) //控制台打印出true
```

上边的例子数组中只有一个值，可能你会多少有些疑惑，我们就来个多个值的数组，并给他一些默认值。

```js
let [a, b = 'dmz'] = ['代码仔']
console.log(a + b) //控制台显示“代码仔dmz”
```

现在我们对默认值有所了解，需要注意的是 undefined 和 null 的区别。

```js
let [a, b = 'dmz'] = ['代码仔', undefined]
console.log(a + b) //控制台显示“代码仔dmz”
```

undefined 相当于什么都没有，b 是默认值。

```js
let [a, b = 'dmz'] = ['代码仔', null]
console.log(a + b) //控制台显示“代码仔null”
```

null 相当于有值，但值为 null。所以 b 并没有取默认值，而是解构成了 null。

## 对象的解构赋值

解构不仅可以用于数组，还可以用于对象。

```js
let { foo, bar } = { foo: 'dmz', bar: '代码仔' }
console.log(foo + bar) //控制台打印出了“dmz代码仔”
```

注意：对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。

## 圆括号的使用

如果在解构之前就定义了变量，这时候你再解构会出现问题。下面是错误的代码，编译会报错。

```js
 let foo;
  {foo} ={foo:'dmz'};
  console.log(foo);
```

要解决报错，使程序正常，我们这时候只要在解构的语句外边加一个圆括号就可以了。

```js
let foo
;({ foo } = { foo: 'dmz' })
console.log(foo) //控制台输出dmz
```

## 字符串解构

字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。

```js
const [a, b, c, d, e, f] = 'dmz'
console.log(a)
console.log(b)
console.log(c)
console.log(d)
console.log(e)
console.log(f)
```

总结：这节课的内容很简单，但是也有一些细节需要注意，希望你能动手把解构练习一遍，在实战项目中解构 Json 数据格式还是很普遍的，有了 ES6 得帮助，提高了不少工作效率。

# 扩展运算符和 rest 运算符

## 对象扩展运算符（…）

当编写一个方法时，我们允许它传入的参数是不确定的。这时候可以使用对象扩展运算符来作参数，看一个简单的列子：

```js
function dmz(...arg) {
  console.log(arg[0])
  console.log(arg[1])
  console.log(arg[2])
  console.log(arg[3])
}
dmz(1, 2, 3)
```

这时我们看到控制台输出了 1,2,3，undefined，这说明是可以传入多个值，并且就算方法中引用多了也不会报错。

## 扩展运算符的用处

我们先用一个例子说明，我们声明两个数组 arr1 和 arr2，然后我们把 arr1 赋值给 arr2，然后我们改变 arr2 的值，你会发现 arr1 的值也改变了，因为我们这是对内存堆栈的引用，而不是真正的赋值。

```js
let arr1 = ['www', 'dmz', 'com']
let arr2 = arr1
console.log(arr2)
arr2.push('shengHongYu')
console.log(arr1)
```

控制台输出：

```js
;['www', 'dmz', 'com'][('www', 'dmz', 'com', 'shengHongYu')]
```

这是我们不想看到的，可以利用对象扩展运算符简单的解决这个问题，现在我们对代码进行改造。

```js
let arr1 = ['www', 'dmz', 'com']
//let arr2=arr1;
let arr2 = [...arr1]
console.log(arr2)
arr2.push('shengHongYu')
console.log(arr2)
console.log(arr1)
```

现在控制台预览时，你可以看到我们的 arr1 并没有改变，简单的扩展运算符就解决了这个问题。

## rest 运算符

如果你已经很好的掌握了对象扩展运算符，那么理解 rest 运算符并不困难，它们有很多相似之处，甚至很多时候你不用特意去区分。它也用…（三个点）来表示，我们先来看一个例子。

```js
function dmz(first, ...arg) {
  console.log(arg.length)
}

dmz(0, 1, 2, 3, 4, 5, 6, 7)
```

这时候控制台打印出了 7，说明我们 arg 里有 7 个数组元素，这就是 rest 运算符的最简单用法。

如何循环输出 rest 运算符

这里我们用 for…of 循环来进行打印出 arg 的值，我们这里只是简单使用一下，以后我们会专门讲解 for…of 循环。

```js
function dmz(first, ...arg) {
  for (let val of arg) {
    console.log(val)
  }
}

dmz(0, 1, 2, 3, 4, 5, 6, 7)
```

for…of 的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用 for…of 循环。有的小伙伴会说了，反正最后要转换成 ES5，没有什么差别，但是至少从代码量上我们少打了一些单词，这就是开发效率的提高。

总结：我们这节课学习了对象扩展运算符和 reet 运算符，它们两个还是非常类似的，但是你要自己区分，这样才能在工作中运用自如。在以后的课程中还会有很多关于扩展运算符和 rset 运算符的妙用，让我们一起期待吧。
