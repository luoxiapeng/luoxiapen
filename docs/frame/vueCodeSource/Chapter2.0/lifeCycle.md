# 10 | 生命周期：各个生命周期的执行时机和应用场景是怎样的？

在前面的课时中，我们多次提到回调函数是以一种调度的方式执行的，特别是当 flush 不是 sync 时，它会把回调函数执行的任务推到一个异步队列中执行。接下来，我们就来分析异步执行队列的设计。分析之前，我们先来思考一下，为什么会需要异步队列？

## 异步任务队列的设计
我们把之前的例子简单修改一下：

```js
import { reactive, watch } from 'vue' 

const state = reactive({ count: 0 }) 

watch(() => state.count, (count, prevCount) => { 

  console.log(count) 

}) 

state.count++ 

state.count++ 

state.count++ 

```
这里，我们修改了三次 state.count，那么 watcher 的回调函数会执行三次吗？

答案是不会，实际上只输出了一次 count 的值，也就是最终计算的值 3。这在大多数场景下都是符合预期的，因为在一个 Tick（宏任务执行的生命周期）内，即使多次修改侦听的值，它的回调函数也只执行一次。

> 知识延伸
  组件的更新过程是异步的，我们知道修改模板中引用的响应式对象的值时，会触发组件的重新渲染，但是在一个 Tick 内，即使你多次修改多个响应式对象的值，组件的重新渲染也只执行一次。这是因为如果每次更新数据都触发组件重新渲染，那么重新渲染的次数和代价都太高了。

那么，这是怎么做到的呢？我们先从异步任务队列的创建说起。